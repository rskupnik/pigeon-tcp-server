{
  "name": "Pigeon TCP Server",
  "tagline": "Pigeon is a small library for packet transmission for Java",
  "body": "# What is it?\r\n\r\nPigeon is a small library for packet transmission for Java. This module handles the server side of a TCP connection.\r\n\r\n# How to use it?\r\n\r\nYou build a PigeonTcpServer like so:\r\n\r\n```\r\nPigeonTcpServer server = Pigeon.newServer()\r\n    .withPacketHandler(new PacketHandler() {\r\n        @Override\r\n        public void handle(Packet packet) {\r\n\r\n        }\r\n    })\r\n    .build();\r\n    \r\nserver.start();\r\n```\r\n\r\nAt this point Pigeon will establish a server and listen for incoming connections. Provided in the example are minimal required parameters for Pigeon to work - only the packet handler. The rest will be set to defaults.\r\n\r\nHere are all the possible configuration options:\r\n\r\n```\r\nPigeon.newServer()\r\n    .withPort(9191)                                                 // Defaults to 9191\r\n    .withIncomingPacketHandleMode(IncomingPacketHandleMode.HANDLER) // Defaults to HANDLER - see below for more options\r\n    .withPacketHandler(new PacketHandler() {                        // Required when incoming packet mode is HANDLER\r\n        @Override\r\n        public void handle(Packet packet) {\r\n\r\n        }\r\n    })\r\n    .withServerCallbackHandler(clientCallbackHandler)               // Not required, no default\r\n    .withPackageToScan(\"com.github.rskupnik\")                       // Not required, defaults to null which will cause the entire classpath to be scanned\r\n    .withPropertiesFilename(\"my-properties.properties\")             // Points the properties file to load, by default searched for pigeon-tcp-client.properties\r\n    .withReceiverThreadsNumber(0)                                   // Number of threads that will handle new connections, 0 = infinite, defaults to 0\r\n    .build();\r\n```\r\n\r\nMost of these can be provided in a properties file. By default, PigeonTcpServer will look for a pigeon-tcp-server.properties file\r\neither on the classpath or in the project's root folder. You can point to another properties file, however, using the\r\n`withProperties()` builder option - Pigeon will then look for that filename on the classpath or in the project's root folder.\r\n\r\nHere's how a configuration file looks like:\r\n\r\n```\r\nport=9192\r\nreceiver_threads_number=1\r\npackage_to_scan=com.github.rskupnik.pigeon.tcpserver\r\npacket_handle_mode=handler\r\n```\r\n\r\nThe precedence is as follows:\r\n\r\n`manual_input -> configuration_file -> defaults`\r\n\r\nWhich means that Pigeon will first look for configuration values provided manually (by using the `.withXXX()` builder methods) and, if not found, fall back to configuration file and then to default values in case the file is not present as well.\r\n\r\n## Handling packets\r\n\r\nPigeon makes use of annotations to describe packets for sending and receiving.\r\nA valid packet class must conform to these rules:\r\n* Be public\r\n* Extend the `Packet` class\r\n* Be annotated with `@PigeonPacket` (with id provided)\r\n* Have proper getter and setter methods for any variables that should be a part of the packet (annotated with `@PacketDataField`)\r\n\r\n```\r\n@PigeonPacket(id = 1)\r\npublic class TestPacket extends Packet {\r\n\r\n    @PacketDataField\r\n    private int testData;\r\n\r\n    public int getTestData() {\r\n        return testData;\r\n    }\r\n\r\n    public void setTestData(int testData) {\r\n        this.testData = testData;\r\n    }\r\n}\r\n```\r\n\r\nThese packet classes should reside in a single package and Pigeon should be told which package to scan for them (using either\r\nthe configuration file or the `withPackageToScan()` builder method). Pigeon will still work if not provided with the package name\r\nto scan but will initialize much, much slower because it will have to scan the entire classpath.\r\n\r\n### Sending packets\r\n\r\nOnce the packet has been created and found by Pigeon, it can be easily sent using the `.send()` method on the client.\r\n\r\n```\r\nTestPacket packet = new TestPacket();\r\npacket.setTestData(8);\r\n\r\n// Assume we have a properly initiated PigeonTcpServer under the variable 'server' here and a proper connection under 'connection'\r\nserver.send(packet, connection);    // Will send a packet to a single connection\r\nserver.send(packet, Arrays.asList(connection)); // Will send a packet to a list of connections\r\n```\r\n\r\n### Receiving and handling packets\r\n\r\nWhen receiving packets, Pigeon identifies them using the id value provided in the `@PigeonPacket` annotation, so it's very important\r\nto not have overlapping ids.\r\n\r\nOnce a packet is received, there are two modes for handling it - these can be set using the configuration file or\r\nthe `.withIncomingPacketHandleMode()` builder method.\r\n\r\nThe default mode - HANDLER - will make a callback to the handler function you must provide when initializing the client:\r\n\r\n```\r\nPigeon.newServer()\r\n    .withPacketHandler(new PacketHandler() {\r\n        @Override\r\n        public void handle(Packet packet) {\r\n          if (packet.getId() == 1) {\r\n            TestPacket testPacket = (TestPacket) packet;\r\n            // Handle the packet...\r\n          }\r\n        }\r\n    })\r\n    .build();\r\n```\r\n\r\nThe other mode - QUEUE - will put the packet into a queue once it is received. At this point Pigeon stops caring about it,\r\nit's your task to poll the queue periodically and handle the packets.\r\n\r\n```\r\nPigeonTcpServer server = Pigeon.newServer()\r\n    .withIncomingPacketHandleMode(IncomingPacketHandleMode.QUEUE)\r\n    .build();\r\n    \r\nserver.start();\r\n    \r\n// Do this periodically in a separate thread\r\nList<Packet> packets = server.getIncomingPacketQueue().popAll();\r\nfor (Packet packet : packets) {\r\n  if (packet.getId() == 1) {\r\n    TestPacket testPacket = (TestPacket) packet;\r\n    // Handle the packet...\r\n  }\r\n}\r\n```\r\n\r\n### Connection handling threads\r\n\r\nThe `receiverThreadsNumber` configuration property controls how many threads will be used to handle the connections.\r\nIf set to 0 (default), there will be no limit - each new connection will receive a separate thread to handle it.\r\nIf set to a value > 0, a thread pool will be established with limited capacity and only as many connections will\r\nbe allowed as many threads are available to handle them. Therefore, if you set this value to 1, Pigeon will only\r\nhandle a single connection and reject any further connections until the thread is free.\r\n\r\n## Callbacks\r\n\r\nYou can provide Pigeon with a callback handler if you want to receive callbacks when specific things happen.\r\n\r\n```\r\nclass TestServerCallbackHandler implements ServerCallbackHandler {\r\n\r\n    @Override\r\n    public void onStarted() {\r\n\r\n    }\r\n\r\n    @Override\r\n    public void onNewConnection(Connection connection) {\r\n        connections.add(connection);    // You might want to keep track of your connections\r\n    }\r\n}\r\n\r\nPigeonTcpServer server = Pigeon.newServer()\r\n    .withIncomingPacketHandleMode(IncomingPacketHandleMode.QUEUE)\r\n    .withClientCallbackHandler(new TestServerCallbackHandler())\r\n    .build();\r\n```\r\n\r\nCurrently, PigeonTcpServer only provides callback for the `onStarted` and `onNewConnection` events.\r\n\r\n# Rationale\r\n\r\nI've found myself often in need of a simple library for handling packet communication in Java. Available libraries\r\nwhere usually too complex and rewriting the same custom code in each hobby project was tedious. I've created Pigeon to \r\nbe able to implement packet communication quickly and be able to define new packets easily - with annotations and \r\nno wiring required.\r\n\r\nPigeon does not aim to be the most performant, the most configurable or the safest packet handling library out there. It rather aims\r\nto be simple, easy to use and pick up. Therefore, it is mostly suitable for small hobby projects.\r\n\r\n# Future\r\n\r\n* Handle more data types than just integer and string\r\n* Add support for SSL encryption?\r\n* Perhaps other incoming packet handle modes?\r\n* More callback functions\r\n",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}